{"version":3,"file":"prefix-functions.js","sourceRoot":"","sources":["../../src/transforms/prefix-functions.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\n\r\n\r\nexport function getPrefixFunctionsTransformer(): ts.TransformerFactory<ts.SourceFile> {\r\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\r\n    const transformer: ts.Transformer<ts.SourceFile> = (sf: ts.SourceFile) => {\r\n\r\n      const pureFunctionComment = '@__PURE__';\r\n      const topLevelFunctions = findTopLevelFunctions(sf);\r\n      const pureImports = findPureImports(sf);\r\n      const pureImportsComment = `* PURE_IMPORTS_START ${pureImports.join(',')} PURE_IMPORTS_END `;\r\n\r\n      const visitor: ts.Visitor = (node: ts.Node): ts.Node => {\r\n\r\n        // Add the pure imports comment to the first node.\r\n        if (node.parent && node.parent.parent === undefined && node.pos === 0) {\r\n          const newNode = ts.addSyntheticLeadingComment(\r\n            node, ts.SyntaxKind.MultiLineCommentTrivia, pureImportsComment, true);\r\n\r\n          // Replace node with modified one.\r\n          return ts.visitEachChild(newNode, visitor, context);\r\n        }\r\n\r\n        // Add pure function comment to top level functions.\r\n        if (topLevelFunctions.indexOf(node) !== -1) {\r\n          const newNode = ts.addSyntheticLeadingComment(\r\n            node, ts.SyntaxKind.MultiLineCommentTrivia, pureFunctionComment, false);\r\n\r\n          // Replace node with modified one.\r\n          return ts.visitEachChild(newNode, visitor, context);\r\n        }\r\n\r\n        // Otherwise return node as is.\r\n        return ts.visitEachChild(node, visitor, context);\r\n      };\r\n\r\n      return ts.visitNode(sf, visitor);\r\n    };\r\n    return transformer;\r\n  };\r\n}\r\n\r\nexport function findTopLevelFunctions(parentNode: ts.Node): ts.Node[] {\r\n  const topLevelFunctions: ts.Node[] = [];\r\n  ts.forEachChild(parentNode, cb);\r\n\r\n  let previousNode: ts.Node;\r\n  function cb(node: ts.Node): any {\r\n    // Stop recursing into this branch if it's a function expression or declaration\r\n    if (node.kind === ts.SyntaxKind.FunctionDeclaration || node.kind === ts.SyntaxKind.FunctionExpression) {\r\n      return;\r\n    }\r\n\r\n    // We need to check specially for IIFEs formatted as call expressions inside parenthesized\r\n    // expressions: `(function() {}())` Their start pos doesn't include the opening paren\r\n    // and must be adjusted.\r\n    if (isIIFE(node) && previousNode.kind === ts.SyntaxKind.ParenthesizedExpression && node.parent) {\r\n      topLevelFunctions.push(node.parent);\r\n    } else if (node.kind === ts.SyntaxKind.CallExpression || node.kind === ts.SyntaxKind.NewExpression) {\r\n      topLevelFunctions.push(node);\r\n    }\r\n\r\n    previousNode = node;\r\n    return ts.forEachChild(node, cb);\r\n\r\n  }\r\n\r\n  function isIIFE(node: any): boolean {\r\n    return node.kind === ts.SyntaxKind.CallExpression && !node.expression.text &&\r\n      node.expression.kind !== ts.SyntaxKind.PropertyAccessExpression;\r\n  }\r\n\r\n  return topLevelFunctions;\r\n}\r\n\r\nexport function findPureImports(parentNode: ts.Node): string[] {\r\n  const pureImports: string[] = [];\r\n  ts.forEachChild(parentNode, cb);\r\n\r\n  function cb(node: any): any {\r\n    if (node.kind === ts.SyntaxKind.ImportDeclaration && node.importClause) {\r\n      // Save the path of the import transformed into snake case\r\n      pureImports.push(node.moduleSpecifier.text.replace(/[\\/@\\-]/g, '_'));\r\n    }\r\n    return ts.forEachChild(node, cb);\r\n  }\r\n  return pureImports;\r\n}\r\n"]}